<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ghana Agriculture Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- CSS -->
  <link rel="stylesheet" href="style.css" />

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500&family=Open+Sans&display=swap" rel="stylesheet" />

</head>
<body>
  <div id="sidebar" class="sidebar">
    <div class="sidebar-header">
      <h2>🌾 Farm Filter</h2>
      <button id="toggleSidebar">⮜</button>
    </div>

    <div class="filters">
      <label for="cropSelect">Crop Type</label>
      <select id="cropSelect">
        <option value="">All Crops</option>
      </select>

      <label for="regionSelect">Region</label>
      <select id="regionSelect">
        <option value="">All Regions</option>
      </select>

      <label for="sizeRange">Farm Size (ha)</label>
      <input type="range" id="sizeRange" min="0" max="100" step="1" />

      <button id="resetFilters" class="reset-btn">Reset Filters</button>
    </div>
  </div>

  <div id="map"></div>

  <div id="footer-tag">Made by Victor Morton-Bruce</div>

  <script>
    // Base Layers
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    });

    const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: '&copy; Esri &mdash; Source: Esri, Earthstar Geographics'
    });

    const map = L.map('map', {
      center: [7.9, -1.0],
      zoom: 7,
      layers: [satellite]
    });

    const baseMaps = { "Satellite": satellite, "OpenStreetMap": osm };
    L.control.layers(baseMaps).addTo(map);

    // Load GeoJSON
    let farmLayer;
   fetch('data/ghana_farms_polygons.geojson')
  .then(response => response.json())
  .then(data => {
    // Extract unique crop types and regions
    const crops = [...new Set(data.features.map(f => f.properties.crop))];
    const regions = [...new Set(data.features.map(f => f.properties.region))];

    // Populate dropdowns dynamically
    const cropSelect = document.getElementById('cropSelect');
    const regionSelect = document.getElementById('regionSelect');

    crops.forEach(crop => {
      const option = document.createElement('option');
      option.value = crop;
      option.textContent = crop;
      cropSelect.appendChild(option);
    });

    regions.forEach(region => {
      const option = document.createElement('option');
      option.value = region;
      option.textContent = region;
      regionSelect.appendChild(option);
    });

    // Define color mapping by crop type
    const cropColors = {
      "Maize": "#f9a825",
      "Cassava": "#8bc34a",
      "Cocoa": "#6d4c41",
      "Rice": "#4fc3f7",
      "Tomatoes": "#e53935"
    };

    // Add farms to the map
    const farmsLayer = L.geoJSON(data, {
      style: feature => ({
        color: '#222',
        weight: 0.8,
        fillColor: cropColors[feature.properties.crop] || '#999',
        fillOpacity: 0.6
      }),
      onEachFeature: (feature, layer) => {
        const p = feature.properties;
        layer.bindPopup(`
          <strong>${p.farm_name}</strong><br>
          Farmer: ${p.farmer}<br>
          Crop: ${p.crop}<br>
          Region: ${p.region}<br>
          Area: ${p.area_ha} ha
        `);
      }
    }).addTo(map);

    // ✅ Auto-fit to all farms
    map.fitBounds(farmsLayer.getBounds());

    // Filtering logic
    function applyFilters() {
      const selectedCrop = cropSelect.value;
      const selectedRegion = regionSelect.value;
      const sizeThreshold = document.getElementById('sizeRange').value;

      farmsLayer.eachLayer(layer => {
        const p = layer.feature.properties;
        const match =
          (selectedCrop === "All Crops" || p.crop === selectedCrop) &&
          (selectedRegion === "All Regions" || p.region === selectedRegion) &&
          p.area_ha >= sizeThreshold;

        layer.setStyle({ opacity: match ? 1 : 0, fillOpacity: match ? 0.6 : 0 });
      });
    }

    // Event listeners
    cropSelect.addEventListener('change', applyFilters);
    regionSelect.addEventListener('change', applyFilters);
    document.getElementById('sizeRange').addEventListener('input', applyFilters);
    document.getElementById('resetFilters').addEventListener('click', () => {
      cropSelect.value = "All Crops";
      regionSelect.value = "All Regions";
      document.getElementById('sizeRange').value = 0;
      applyFilters();
    });
  });
 {
        farmLayer = L.geoJSON(data, {
         style: function(feature) {
  return {
    color: '#222',           // thin dark border
    weight: 0.8,
    fillColor: cropColors[feature.properties.crop] || '#ccc',
    fillOpacity: 0.6
  };
}
,
          onEachFeature: (feature, layer) => {
            const p = feature.properties;
            layer.bindPopup(`
              <b>${p.farm_name}</b><br>
              👨🏽‍🌾 <b>Farmer:</b> ${p.farmer}<br>
              🌱 <b>Crop:</b> ${p.crop}<br>
              📍 <b>Region:</b> ${p.region}<br>
              🌾 <b>Area:</b> ${p.area_ha} ha<br>
              📊 <b>Yield:</b> ${p.yield_tons} tons
            `);
          }
        }).addTo(map);
        map.fitBounds(farmLayer.getBounds());

        populateFilters(data.features);
        attachFilterEvents(data.features);
      };

    function getCropColor(crop) {
      const colors = {
        'Maize': '#fbc02d',
        'Cocoa': '#5d4037',
        'Rice': '#81c784',
        'Cassava': '#f5f5f5',
        'Tomatoes': '#ef5350'
      };
      return colors[crop] || '#cccccc';
    }

    function populateFilters(features) {
      const crops = [...new Set(features.map(f => f.properties.crop))];
      const regions = [...new Set(features.map(f => f.properties.region))];
      const cropSelect = document.getElementById('cropSelect');
      const regionSelect = document.getElementById('regionSelect');
      const sizeRange = document.getElementById('sizeRange');

      const allAreas = features.map(f => f.properties.area_ha);
      sizeRange.min = Math.min(...allAreas);
      sizeRange.max = Math.max(...allAreas);

      crops.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c;
        opt.textContent = c;
        cropSelect.appendChild(opt);
      });
      regions.forEach(r => {
        const opt = document.createElement('option');
        opt.value = r;
        opt.textContent = r;
        regionSelect.appendChild(opt);
      });
    }

    function attachFilterEvents(allFeatures) {
      const cropSelect = document.getElementById('cropSelect');
      const regionSelect = document.getElementById('regionSelect');
      const sizeRange = document.getElementById('sizeRange');
      const resetBtn = document.getElementById('resetFilters');

      function filterData() {
        const cropVal = cropSelect.value;
        const regionVal = regionSelect.value;
        const sizeVal = parseInt(sizeRange.value);

        if (farmLayer) map.removeLayer(farmLayer);

        const filtered = allFeatures.filter(f => {
          const p = f.properties;
          return (!cropVal || p.crop === cropVal) &&
                 (!regionVal || p.region === regionVal) &&
                 (!sizeVal || p.area_ha >= sizeVal);
        });

        farmLayer = L.geoJSON({ type: 'FeatureCollection', features: filtered }, {
          style: f => ({
            color: '#2b2b2b',
            weight: 1,
            fillOpacity: 0.75,
            fillColor: getCropColor(f.properties.crop)
          }),
          onEachFeature: (f, l) => {
            const p = f.properties;
            l.bindPopup(`
              <b>${p.farm_name}</b><br>
              👨🏽‍🌾 <b>Farmer:</b> ${p.farmer}<br>
              🌱 <b>Crop:</b> ${p.crop}<br>
              📍 <b>Region:</b> ${p.region}<br>
              🌾 <b>Area:</b> ${p.area_ha} ha<br>
              📊 <b>Yield:</b> ${p.yield_tons} tons
            `);
          }
        }).addTo(map);

        if (filtered.length > 0) {
          map.fitBounds(farmLayer.getBounds());
        }
      }

      cropSelect.addEventListener('change', filterData);
      regionSelect.addEventListener('change', filterData);
      sizeRange.addEventListener('input', filterData);
      resetBtn.addEventListener('click', () => {
        cropSelect.value = '';
        regionSelect.value = '';
        sizeRange.value = sizeRange.min;
        filterData();
      });
    }

    // Sidebar toggle
    document.getElementById('toggleSidebar').addEventListener('click', () => {
      document.getElementById('sidebar').classList.toggle('collapsed');
    });

  </script>
</body>
</html>
